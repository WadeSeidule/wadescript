use std::fmt;

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct SourceLocation {
    pub line: usize,
    pub column: usize,
}

impl SourceLocation {
    pub fn new(line: usize, column: usize) -> Self {
        SourceLocation { line, column }
    }
}

impl fmt::Display for SourceLocation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "line {}, column {}", self.line, self.column)
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct TokenWithLocation {
    pub token: Token,
    pub location: SourceLocation,
}

impl TokenWithLocation {
    pub fn new(token: Token, location: SourceLocation) -> Self {
        TokenWithLocation { token, location }
    }
}

#[derive(Debug, Clone, PartialEq)]
#[allow(dead_code)]  // Some tokens reserved for future features
pub enum Token {
    // Literals
    IntLiteral(i64),
    FloatLiteral(f64),
    StringLiteral(String),
    FStringLiteral(String), // Raw f-string with {} placeholders
    BoolLiteral(bool),

    // Identifiers and keywords
    Identifier(String),
    Def,
    Class,
    Import,
    If,
    Elif,
    Else,
    While,
    For,
    In,
    Return,
    Pass,
    Break,
    Continue,
    Assert,
    Try,
    Except,
    Finally,
    Raise,
    As,
    And,
    Or,
    Not,
    True,
    False,
    None,

    // Types
    IntType,
    FloatType,
    BoolType,
    StrType,
    ListType,
    DictType,

    // Operators
    Plus,
    Minus,
    Star,
    Slash,
    Percent,
    DoubleSlash,
    DoubleStar,
    Equal,
    PlusEqual,
    MinusEqual,
    StarEqual,
    SlashEqual,
    PlusPlus,
    MinusMinus,
    DoubleEqual,
    NotEqual,
    Less,
    Greater,
    LessEqual,
    GreaterEqual,

    // Delimiters
    LeftParen,
    RightParen,
    LeftBrace,
    RightBrace,
    LeftBracket,
    RightBracket,
    Comma,
    Colon,
    Semicolon,
    Arrow,
    Dot,

    // Special
    Newline,
    Eof,
}

impl fmt::Display for Token {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

pub struct Lexer {
    input: Vec<char>,
    position: usize,
    current_char: Option<char>,
    line: usize,
    column: usize,
}

impl Lexer {
    pub fn new(input: String) -> Self {
        let chars: Vec<char> = input.chars().collect();
        let current_char = chars.get(0).copied();
        Lexer {
            input: chars,
            position: 0,
            current_char,
            line: 1,
            column: 1,
        }
    }

    pub fn current_location(&self) -> SourceLocation {
        SourceLocation::new(self.line, self.column)
    }

    fn make_token(&self, token: Token, location: SourceLocation) -> TokenWithLocation {
        TokenWithLocation::new(token, location)
    }

    fn advance(&mut self) {
        if let Some('\n') = self.current_char {
            self.line += 1;
            self.column = 1;
        } else {
            self.column += 1;
        }
        self.position += 1;
        self.current_char = self.input.get(self.position).copied();
    }

    fn peek(&self, offset: usize) -> Option<char> {
        self.input.get(self.position + offset).copied()
    }

    fn skip_whitespace(&mut self) {
        while let Some(ch) = self.current_char {
            if ch == ' ' || ch == '\t' || ch == '\r' {
                self.advance();
            } else {
                break;
            }
        }
    }

    fn skip_comment(&mut self) {
        if self.current_char == Some('#') {
            while self.current_char.is_some() && self.current_char != Some('\n') {
                self.advance();
            }
        }
    }

    fn read_number(&mut self) -> Token {
        let mut num_str = String::new();
        let mut is_float = false;

        while let Some(ch) = self.current_char {
            if ch.is_ascii_digit() {
                num_str.push(ch);
                self.advance();
            } else if ch == '.' && self.peek(1).map_or(false, |c| c.is_ascii_digit()) {
                is_float = true;
                num_str.push(ch);
                self.advance();
            } else {
                break;
            }
        }

        if is_float {
            Token::FloatLiteral(num_str.parse().unwrap())
        } else {
            Token::IntLiteral(num_str.parse().unwrap())
        }
    }

    fn read_string(&mut self, quote: char) -> Token {
        let mut string = String::new();
        self.advance(); // skip opening quote

        while let Some(ch) = self.current_char {
            if ch == quote {
                self.advance(); // skip closing quote
                break;
            } else if ch == '\\' {
                self.advance();
                if let Some(escaped) = self.current_char {
                    let escaped_char = match escaped {
                        'n' => '\n',
                        't' => '\t',
                        'r' => '\r',
                        '\\' => '\\',
                        '\'' => '\'',
                        '"' => '"',
                        _ => escaped,
                    };
                    string.push(escaped_char);
                    self.advance();
                }
            } else {
                string.push(ch);
                self.advance();
            }
        }

        Token::StringLiteral(string)
    }

    fn read_fstring(&mut self, quote: char) -> Token {
        let mut string = String::new();
        self.advance(); // skip opening quote

        while let Some(ch) = self.current_char {
            if ch == quote {
                self.advance(); // skip closing quote
                break;
            } else if ch == '\\' {
                self.advance();
                if let Some(escaped) = self.current_char {
                    let escaped_char = match escaped {
                        'n' => '\n',
                        't' => '\t',
                        'r' => '\r',
                        '\\' => '\\',
                        '\'' => '\'',
                        '"' => '"',
                        '{' => '{',
                        '}' => '}',
                        _ => escaped,
                    };
                    string.push(escaped_char);
                    self.advance();
                }
            } else {
                string.push(ch);
                self.advance();
            }
        }

        Token::FStringLiteral(string)
    }

    fn read_identifier(&mut self) -> Token {
        let mut ident = String::new();

        while let Some(ch) = self.current_char {
            if ch.is_alphanumeric() || ch == '_' {
                ident.push(ch);
                self.advance();
            } else {
                break;
            }
        }

        match ident.as_str() {
            "def" => Token::Def,
            "class" => Token::Class,
            "import" => Token::Import,
            "if" => Token::If,
            "elif" => Token::Elif,
            "else" => Token::Else,
            "while" => Token::While,
            "for" => Token::For,
            "in" => Token::In,
            "return" => Token::Return,
            "pass" => Token::Pass,
            "break" => Token::Break,
            "continue" => Token::Continue,
            "assert" => Token::Assert,
            "try" => Token::Try,
            "except" => Token::Except,
            "finally" => Token::Finally,
            "raise" => Token::Raise,
            "as" => Token::As,
            "and" => Token::And,
            "or" => Token::Or,
            "not" => Token::Not,
            "True" => Token::True,
            "False" => Token::False,
            "None" => Token::None,
            "int" => Token::IntType,
            "float" => Token::FloatType,
            "bool" => Token::BoolType,
            "str" => Token::StrType,
            "list" => Token::ListType,
            "dict" => Token::DictType,
            _ => Token::Identifier(ident),
        }
    }

    pub fn next_token(&mut self) -> TokenWithLocation {
        loop {
            self.skip_whitespace();

            if self.current_char == Some('#') {
                self.skip_comment();
                continue;
            }

            // Capture location at start of token
            let location = self.current_location();

            match self.current_char {
                None => return TokenWithLocation::new(Token::Eof, location),
                Some('\n') => {
                    self.advance();
                    return TokenWithLocation::new(Token::Newline, location);
                }
                Some(ch) if ch.is_ascii_digit() => {
                    let token = self.read_number();
                    return self.make_token(token, location);
                }
                Some('f') => {
                    // Check if this is an f-string
                    if self.position + 1 < self.input.len() {
                        let next_char = self.input[self.position + 1];
                        if next_char == '"' || next_char == '\'' {
                            self.advance(); // skip 'f'
                            let token = self.read_fstring(next_char);
                            return self.make_token(token, location);
                        }
                    }
                    // Otherwise it's just an identifier
                    let token = self.read_identifier();
                    return self.make_token(token, location);
                }
                Some(ch) if ch.is_alphabetic() || ch == '_' => {
                    let token = self.read_identifier();
                    return self.make_token(token, location);
                }
                Some('"') => {
                    let token = self.read_string('"');
                    return self.make_token(token, location);
                }
                Some('\'') => {
                    let token = self.read_string('\'');
                    return self.make_token(token, location);
                }
                Some('+') => {
                    self.advance();
                    let token = if self.current_char == Some('+') {
                        self.advance();
                        Token::PlusPlus
                    } else if self.current_char == Some('=') {
                        self.advance();
                        Token::PlusEqual
                    } else {
                        Token::Plus
                    };
                    return self.make_token(token, location);
                }
                Some('-') => {
                    self.advance();
                    let token = if self.current_char == Some('-') {
                        self.advance();
                        Token::MinusMinus
                    } else if self.current_char == Some('>') {
                        self.advance();
                        Token::Arrow
                    } else if self.current_char == Some('=') {
                        self.advance();
                        Token::MinusEqual
                    } else {
                        Token::Minus
                    };
                    return self.make_token(token, location);
                }
                Some('*') => {
                    self.advance();
                    let token = if self.current_char == Some('*') {
                        self.advance();
                        Token::DoubleStar
                    } else if self.current_char == Some('=') {
                        self.advance();
                        Token::StarEqual
                    } else {
                        Token::Star
                    };
                    return self.make_token(token, location);
                }
                Some('/') => {
                    self.advance();
                    let token = if self.current_char == Some('/') {
                        self.advance();
                        Token::DoubleSlash
                    } else if self.current_char == Some('=') {
                        self.advance();
                        Token::SlashEqual
                    } else {
                        Token::Slash
                    };
                    return self.make_token(token, location);
                }
                Some('%') => {
                    self.advance();
                    return self.make_token(Token::Percent, location);
                }
                Some('=') => {
                    self.advance();
                    let token = if self.current_char == Some('=') {
                        self.advance();
                        Token::DoubleEqual
                    } else {
                        Token::Equal
                    };
                    return self.make_token(token, location);
                }
                Some('!') => {
                    self.advance();
                    if self.current_char == Some('=') {
                        self.advance();
                        return self.make_token(Token::NotEqual, location);
                    }
                    panic!("Unexpected character: !");
                }
                Some('<') => {
                    self.advance();
                    let token = if self.current_char == Some('=') {
                        self.advance();
                        Token::LessEqual
                    } else {
                        Token::Less
                    };
                    return self.make_token(token, location);
                }
                Some('>') => {
                    self.advance();
                    let token = if self.current_char == Some('=') {
                        self.advance();
                        Token::GreaterEqual
                    } else {
                        Token::Greater
                    };
                    return self.make_token(token, location);
                }
                Some('(') => {
                    self.advance();
                    return self.make_token(Token::LeftParen, location);
                }
                Some(')') => {
                    self.advance();
                    return self.make_token(Token::RightParen, location);
                }
                Some('{') => {
                    self.advance();
                    return self.make_token(Token::LeftBrace, location);
                }
                Some('}') => {
                    self.advance();
                    return self.make_token(Token::RightBrace, location);
                }
                Some('[') => {
                    self.advance();
                    return self.make_token(Token::LeftBracket, location);
                }
                Some(']') => {
                    self.advance();
                    return self.make_token(Token::RightBracket, location);
                }
                Some(',') => {
                    self.advance();
                    return self.make_token(Token::Comma, location);
                }
                Some(':') => {
                    self.advance();
                    return self.make_token(Token::Colon, location);
                }
                Some(';') => {
                    self.advance();
                    return self.make_token(Token::Semicolon, location);
                }
                Some('.') => {
                    self.advance();
                    return self.make_token(Token::Dot, location);
                }
                Some(ch) => {
                    panic!("Unexpected character: {}", ch);
                }
            }
        }
    }

    pub fn tokenize(&mut self) -> Vec<TokenWithLocation> {
        let mut tokens = Vec::new();
        loop {
            let token_with_loc = self.next_token();
            if token_with_loc.token == Token::Eof {
                tokens.push(token_with_loc);
                break;
            }
            tokens.push(token_with_loc);
        }
        tokens
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_integer_literals() {
        let mut lexer = Lexer::new("42 0 123 9999".to_string());
        let tokens = lexer.tokenize();
        assert_eq!(tokens[0].token, Token::IntLiteral(42));
        assert_eq!(tokens[1].token, Token::IntLiteral(0));
        assert_eq!(tokens[2].token, Token::IntLiteral(123));
        assert_eq!(tokens[3].token, Token::IntLiteral(9999));
    }

    #[test]
    fn test_float_literals() {
        let mut lexer = Lexer::new("3.14 0.5 123.456".to_string());
        let tokens = lexer.tokenize();
        assert_eq!(tokens[0].token, Token::FloatLiteral(3.14));
        assert_eq!(tokens[1].token, Token::FloatLiteral(0.5));
        assert_eq!(tokens[2].token, Token::FloatLiteral(123.456));
    }

    #[test]
    fn test_string_literals() {
        let mut lexer = Lexer::new(r#""hello" "world" "test string""#.to_string());
        let tokens = lexer.tokenize();
        assert_eq!(tokens[0].token, Token::StringLiteral("hello".to_string()));
        assert_eq!(tokens[1].token, Token::StringLiteral("world".to_string()));
        assert_eq!(tokens[2].token, Token::StringLiteral("test string".to_string()));
    }

    #[test]
    fn test_identifiers() {
        let mut lexer = Lexer::new("foo bar x y123 _private".to_string());
        let tokens = lexer.tokenize();
        assert_eq!(tokens[0], Token::Identifier("foo".to_string()));
        assert_eq!(tokens[1], Token::Identifier("bar".to_string()));
        assert_eq!(tokens[2], Token::Identifier("x".to_string()));
        assert_eq!(tokens[3], Token::Identifier("y123".to_string()));
        assert_eq!(tokens[4], Token::Identifier("_private".to_string()));
    }

    #[test]
    fn test_keywords() {
        let mut lexer = Lexer::new("def class if else while for return break continue assert".to_string());
        let tokens = lexer.tokenize();
        assert_eq!(tokens[0], Token::Def);
        assert_eq!(tokens[1], Token::Class);
        assert_eq!(tokens[2], Token::If);
        assert_eq!(tokens[3], Token::Else);
        assert_eq!(tokens[4], Token::While);
        assert_eq!(tokens[5], Token::For);
        assert_eq!(tokens[6], Token::Return);
        assert_eq!(tokens[7], Token::Break);
        assert_eq!(tokens[8], Token::Continue);
        assert_eq!(tokens[9], Token::Assert);
    }

    #[test]
    fn test_operators() {
        let mut lexer = Lexer::new("+ - * / % == != < > <= >= and or not".to_string());
        let tokens = lexer.tokenize();
        assert_eq!(tokens[0], Token::Plus);
        assert_eq!(tokens[1], Token::Minus);
        assert_eq!(tokens[2], Token::Star);
        assert_eq!(tokens[3], Token::Slash);
        assert_eq!(tokens[4], Token::Percent);
        assert_eq!(tokens[5], Token::DoubleEqual);
        assert_eq!(tokens[6], Token::NotEqual);
        assert_eq!(tokens[7], Token::Less);
        assert_eq!(tokens[8], Token::Greater);
        assert_eq!(tokens[9], Token::LessEqual);
        assert_eq!(tokens[10], Token::GreaterEqual);
        assert_eq!(tokens[11], Token::And);
        assert_eq!(tokens[12], Token::Or);
        assert_eq!(tokens[13], Token::Not);
    }

    #[test]
    fn test_compound_operators() {
        let mut lexer = Lexer::new("+= -= *= /= ++ --".to_string());
        let tokens = lexer.tokenize();
        assert_eq!(tokens[0], Token::PlusEqual);
        assert_eq!(tokens[1], Token::MinusEqual);
        assert_eq!(tokens[2], Token::StarEqual);
        assert_eq!(tokens[3], Token::SlashEqual);
        assert_eq!(tokens[4], Token::PlusPlus);
        assert_eq!(tokens[5], Token::MinusMinus);
    }

    #[test]
    fn test_delimiters() {
        let mut lexer = Lexer::new("( ) { } [ ] , : ; -> .".to_string());
        let tokens = lexer.tokenize();
        assert_eq!(tokens[0], Token::LeftParen);
        assert_eq!(tokens[1], Token::RightParen);
        assert_eq!(tokens[2], Token::LeftBrace);
        assert_eq!(tokens[3], Token::RightBrace);
        assert_eq!(tokens[4], Token::LeftBracket);
        assert_eq!(tokens[5], Token::RightBracket);
        assert_eq!(tokens[6], Token::Comma);
        assert_eq!(tokens[7], Token::Colon);
        assert_eq!(tokens[8], Token::Semicolon);
        assert_eq!(tokens[9], Token::Arrow);
        assert_eq!(tokens[10], Token::Dot);
    }

    #[test]
    fn test_comments() {
        let mut lexer = Lexer::new("x # this is a comment\ny".to_string());
        let tokens = lexer.tokenize();
        assert_eq!(tokens[0], Token::Identifier("x".to_string()));
        assert_eq!(tokens[1], Token::Newline);
        assert_eq!(tokens[2], Token::Identifier("y".to_string()));
    }

    #[test]
    fn test_newlines() {
        let mut lexer = Lexer::new("x\n\ny\n".to_string());
        let tokens = lexer.tokenize();
        assert_eq!(tokens[0], Token::Identifier("x".to_string()));
        assert_eq!(tokens[1], Token::Newline);
        assert_eq!(tokens[2], Token::Newline);
        assert_eq!(tokens[3], Token::Identifier("y".to_string()));
        assert_eq!(tokens[4], Token::Newline);
    }

    #[test]
    fn test_simple_expression() {
        let mut lexer = Lexer::new("x = 10 + 5".to_string());
        let tokens = lexer.tokenize();
        assert_eq!(tokens[0], Token::Identifier("x".to_string()));
        assert_eq!(tokens[1], Token::Equal);
        assert_eq!(tokens[2], Token::IntLiteral(10));
        assert_eq!(tokens[3], Token::Plus);
        assert_eq!(tokens[4], Token::IntLiteral(5));
    }

    #[test]
    fn test_function_definition() {
        let mut lexer = Lexer::new("def add(a: int, b: int) -> int".to_string());
        let tokens = lexer.tokenize();
        assert_eq!(tokens[0], Token::Def);
        assert_eq!(tokens[1], Token::Identifier("add".to_string()));
        assert_eq!(tokens[2], Token::LeftParen);
        assert_eq!(tokens[3], Token::Identifier("a".to_string()));
        assert_eq!(tokens[4], Token::Colon);
        assert_eq!(tokens[5], Token::IntType);
        assert_eq!(tokens[6], Token::Comma);
        assert_eq!(tokens[7], Token::Identifier("b".to_string()));
        assert_eq!(tokens[8], Token::Colon);
        assert_eq!(tokens[9], Token::IntType);
        assert_eq!(tokens[10], Token::RightParen);
        assert_eq!(tokens[11], Token::Arrow);
        assert_eq!(tokens[12], Token::IntType);
    }

    #[test]
    fn test_types() {
        let mut lexer = Lexer::new("int float bool str list dict".to_string());
        let tokens = lexer.tokenize();
        assert_eq!(tokens[0], Token::IntType);
        assert_eq!(tokens[1], Token::FloatType);
        assert_eq!(tokens[2], Token::BoolType);
        assert_eq!(tokens[3], Token::StrType);
        assert_eq!(tokens[4], Token::ListType);
        assert_eq!(tokens[5], Token::DictType);
    }

    #[test]
    fn test_boolean_literals() {
        let mut lexer = Lexer::new("True False".to_string());
        let tokens = lexer.tokenize();
        assert_eq!(tokens[0], Token::True);
        assert_eq!(tokens[1], Token::False);
    }

    #[test]
    fn test_fstring() {
        let mut lexer = Lexer::new(r#"f"Hello {name}""#.to_string());
        let tokens = lexer.tokenize();
        assert_eq!(tokens[0], Token::FStringLiteral("Hello {name}".to_string()));
    }
}
